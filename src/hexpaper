// hexpaper - library for working with hexagon grids 
//
// Copyright (C) 2014 Garyl Hester
//
// This is the main header file. It includes the various
// components of the library and defines the following
// namespaces:
// 
// org::codefool::hexpaper - main namespace
// - defaults              - defaults for hexpaper processing
//
// methods:
//  hexAtVector
//
//
#ifndef ORG_CODEFOOL_HEXPAPER_INCLUDED_
#define ORG_CODEFOOL_HEXPAPER_INCLUDED_

#include <iostream>
#include <algorithm>
#include <iterator>
#include <vector>
#include <deque>
#include <memory>
#include <utility>

namespace org {
namespace codefool {
namespace hexpaper {

// Forward define all classes
class Facing;
class Offset;
class Hex;
class HexWalker;
class _settings;

// Grid Domination
//
// An odd-grid is on where the hex of an odd-column is above (at facing B or F) of the
// same row number. An even-grid is the opposite:
//
//  Odd Grid:          Even Grid:             Primary Facings:
//   __    __    __        __    __                ___
//  /11\__/31\__/51\    __/21\__/41\__         ___/ A \___
//  \__/21\__/41\__/   /11\__/31\__/51\       / F \___/ B \   *
//  /12\__/32\__/52\   \__/22\__/42\__/       \___/   \___/
//  \__/22\__/42\__/   /12\__/32\__/52\       / E \___/ C \   *
//  /13\__/33\__/53\   \__/23\__/43\__/       \___/ D \___/
//  \__/23\__/43\__/   /13\__/33\__/53\           \___/
//  /14\__/34\__/54\   \__/24\__/44\__/
//
// Delta Column (dc) and Delta row (dr) for each facing, for odd grid:
//
//                 A   B   C   D   E   F
// dc              0   1   1   0  -1  -1
// dr (odd col)   -1  -1   0   1   0  -1
// dr (even col)  -1   0   1   1   1   0
//
// And for even grid:
//
//                 A   B   C   D   E   F
// dc              0   1   1   0  -1  -1
// dr (odd col)   -1   0   1   1   1   0
// dr (even col)  -1  -1   0   1   0  -1
//
// Note that the dr values for odd/even col for odd grid are even/odd col for even grid.
// Hence, we can determine which we should use by IS_ODD(col) XOR IS_ODD(grid)
//
typedef signed short                      coord_t;
typedef std::shared_ptr<std::vector<Hex>> hexfield_t;

extern coord_t _dc[6];
extern coord_t _dr[][6];

template <typename T>
bool isOdd(T x)  { return (bool)(x&0x1); }

template <>
bool isOdd<char *>(char *c);

template <>
bool isOdd<std::string>(std::string s);

template <typename T>
bool isEven(T x) { return (int)(!isOdd(x)); }

//  Primary Facings:
//       ___     ___
// 		/fa \___/ab \		*
// 	    \___/ A \___/
// 	 ___/ F \___/ B \___
// 	/ef \___/   \___/bc \	*
// 	\___/ E \___/ C \___/
// 		\___/ D \___/
// 		/ de\___/cd \		*
// 		\___/   \___/
//
// A hexagon is made up of six equalateral triangles. If we assign the side of
// that triangle a length 2, then it can be divided into two right triangles
// of the dimensions base(1), height(sqrt(3)), and hyp(2).
//
//
extern const double PI;
extern const double PI2RADS;
extern const double SQRT3;

// define some handy Facing constants
extern const Facing _FacingA;
extern const Facing _FacingB;
extern const Facing _FacingC;
extern const Facing _FacingD;
extern const Facing _FacingE;
extern const Facing _FacingF;
extern const Facing _FacingX;

class Facing
{
public:
    enum Face
    {
        FACE_A = 0,
        FACE_B,
        FACE_C,
        FACE_D,
        FACE_E,
        FACE_F,
        FACE_CNT
    };

    Facing( const Face f = FACE_A );
    Facing( const char face );
    Facing( const Facing& obj );
    Facing operator-( const Facing& rhs ) const;
    Facing operator+( const Facing& rhs ) const ;
    Facing operator+( const int bias ) const;
    Facing operator-( const int bias ) const;
    Facing& operator--();
    Facing  operator--(int);
    Facing& operator++();
    Facing  operator++(int);
    Facing& operator+=( const int bias );
    Facing& operator-=( const int bias );
    Facing operator<<( const int bias ) const;
    Facing operator>>( const int bias ) const;
    Face face( void ) const { return _face; }
    operator int() const { return (int)_face; }
    friend std::ostream& operator << (std::ostream& os, const Facing& f );

    class iterator : public std::iterator<std::forward_iterator_tag, Face>
    {
    public:
        iterator( const Facing face = _FacingA );
        iterator( const iterator& other );
        bool operator==( const iterator& other ) const;
        bool operator !=(const iterator& other ) const;
        Face operator*();
        iterator& operator++();
        iterator operator++(int);
        iterator begin();
        iterator end();
        iterator& next();
    private:
        std::shared_ptr<Facing> _face;
        Facing::Face		    _cur;
        int    					_cnt;
    };

    iterator begin() { return Facing::iterator( *this ); }
    iterator end()   { return Facing::iterator( _FacingX ); }

private:
    Face    _face;
};

// Vector - container for direction and distance.
struct Vector
{
    Facing _facing;
    int    _range;
};

// Offset -
class Offset
{
public:
    Offset(coord_t dc, coord_t dr);
    Offset(const Offset& obj );
    ~Offset();
    Offset operator~() const;
    inline coord_t dc( void ) const { return _dc; }
    inline coord_t dr( void ) const { return _dr; }
    friend std::ostream& operator << (std::ostream& os, const Offset& obj );
private:
    coord_t _dc;
    coord_t _dr;
};

class Hex
{
public:
    Hex( coord_t col, coord_t row);
    Hex( const Hex& obj );
    Hex( Offset& off );
    virtual ~Hex();
    coord_t row( void ) const { return _row; }
    coord_t col( void ) const { return _col; }
    Offset delta(const Facing& f) const;
    Hex& move( const Facing& dir, int distance = 1, const Facing& bias = _FacingA );
    Hex at( const Facing& f );
    Hex& operator+=( const Offset& off );
    Hex  operator+( const Offset& off );
    Offset operator-( const Hex& rhs ) const;
    bool operator==(const Hex& rhs ) const;
    bool operator!=(const Hex& rhs ) const;
    bool operator> (const Hex& rhs ) const;
    bool operator< (const Hex& rhs ) const;
    bool operator>=(const Hex& rhs ) const;
    bool operator<=(const Hex& rhs ) const;
    hexfield_t neighbors() const;
    double atan( const Hex& dst ) const;
    friend std::ostream& operator<<(std::ostream& os, const Hex& hex);
private:
    coord_t _col;
    coord_t _row;
};

class Heading
{
public:
    Heading( const Hex& loc, const Facing& dir );
    Heading& turn( Facing newDir );
    Heading& forward( const int distance = 1 );
    Heading& left( const int distance = 1 );
    Heading& right( const int distance = 1 );
    Heading& slipLeft( int distance = 1 );
    Heading& slipRight( int distance = 1 );
private:
    Hex     _loc;
    Facing  _dir;
};

class HexWalker
{
public:
    HexWalker();
    HexWalker( const Hex& hex, const bool allowDups = false );
    HexWalker( const HexWalker& obj );

    HexWalker& setOrigin( const Hex& hex );
    // walk the hex around
    //     n   - list of digits - repeat the following command n times.
    //     A-F - move pen in that direction relative to face.
    //     P   - pen down (start recording all hex's from current hex on.)
    //     U   - pen up   (stop recording hex's.)
    //     M   - mark - push this hex on the stack.
    //     R   - recall - pop hex off the stack (and make that hex the current hex.)
    HexWalker& walk( std::string&& path, const Facing& bias = _FacingA );
    HexWalker& seek( const Hex& dst );
    HexWalker& penUp( void );
    HexWalker& penDown( void );
    HexWalker& push( void );
    HexWalker& pop( void );
    HexWalker& clear( void );
    HexWalker& move( const Facing& dir, int cnt, const Facing& bias = _FacingA );
    HexWalker& sort( void );
    hexfield_t trail( void );
    const Hex& hex( void ) const;
    friend std::ostream& operator<<( std::ostream& os, const HexWalker& hw );

private:
    Hex              _h;
    hexfield_t       _trail;
    std::deque<Hex>  _stack;
    bool             _penDown;
    bool             _allowDups;
};

class _settings
{
private:
    bool oddGrid;       // true if grid is odd-dominated, false if even
    bool clippingOn;    // true if clipping is on

    _settings();
    ~_settings();

public:
    static _settings& instance();
    const signed char gridDomination() const;
    const bool isOddGrid() const;
    bool setOddGrid(bool val);
    const bool isClippingOn() const;
    bool setClipping(bool val);
};

extern _settings& settings;     // forward decl

// determine the hex from (col,row) at Vector relative to the given face.
Hex& hexAtVector( const coord_t col, const coord_t row, const Vector& v, const Facing bias = Facing::FACE_A );

// determine the hex from origin hex at Vector relative to the given face.
Hex& hexAtVector( const Hex& org, const Vector& v, const Facing::Face bias = Facing::FACE_A );

// Determine the vector required to get from the origin hex to destination hex
// relative to the given face.
Vector& vectorToHex( const Hex& org, const Hex& dst, const Facing::Face bias = Facing::FACE_A );

// determine the circular field between minRange and maxRange hex's from
// origin hex.
hexfield_t hexCircField( const Hex& org, const int innerRadius = 0, const int outerRadius = 0 );

// determine the hexdrant for the origin hex, at the given Facing(s), relative to
// the provided face, for range hex's.
hexfield_t hexdrant( const Hex& org, const std::vector<Facing>&faces, const int range, const Facing::Face bias = Facing::FACE_A );

// determine the hexdrant for the origin hex, at the given Facing, relative to
// the provided face, for range hex's.
hexfield_t hexdrant( const Hex& org, const Facing bias, const int range );

// determine the hex's that exist between the origin and destination hex's, inclusive.
hexfield_t hexPath( const Hex& org, const Hex& dst );

// determine the hex's that exist from the origin at the given Vector, relative to the given face.
hexfield_t hexPath( const Hex& org, const Vector& v, const Facing::Face bias = Facing::FACE_A );

// makeHexField is used to create a list of arbitrary hex's which are relative
// to an origin hex. This uses a navigate/pen up/pen down approach. Path contains
// a series of one-character directions that are relative to the provided facing.
// Hex's that fall outside grid dimensions are omitted if clipping is active.
//
// org  - the origin hex
// path - a std::string containing the list of one-character commands:
//     n   - list of digits - repeat the following command n times.
//     A-F - move pen in that direction relative to face.
//     P   - pen down (start recording all hex's from current hex on.)
//     U   - pen up   (stop recording hex's.)
//     M   - mark - push this hex on the stack.
//     R   - recall - pop hex off the stack (and make that hex the current hex.)
// face - the initial facing.
//
// The pen is initially UP.
//
hexfield_t makeHexField( const Hex& org, const std::string& path, const Facing::Face face = Facing::FACE_A );

struct HexInfo
{
	const Hex	_ulc;			// upper left corner of hex field
	const Hex   _lrc;			// lower right corner of hex field
	hexfield_t	_hexs;
	HexInfo( const Hex& ulc, const Hex& lrc, hexfield_t hexs = nullptr )
	: _ulc{ ulc }, _lrc{ lrc }, _hexs{ hexs }
	{}
	friend std::ostream& operator << ( std::ostream& os, const HexInfo& hi );
};


} // end ns hexpaper
} // end ns codefool
} // end ns org

#endif // ORG_CODEFOOL_HEXPAPER_INCLUDED_
